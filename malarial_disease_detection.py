# -*- coding: utf-8 -*-
"""jan 17 malaria.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jbFu1OcIx-v_XyYLFEM9V_yAUyjQO7fo

Set Up Environment and Import Libraries
"""

#necessary libraries
import os
import zipfile
import random
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.metrics import classification_report, confusion_matrix
import tensorflow as tf

# Checking TensorFlow version
print(f"TensorFlow version: {tf.__version__}")

"""Upload dataset"""

# Mounting drive
from google.colab import drive
drive.mount('/content/drive')

# Extract the zip file
dataset_path = '/content/drive/My Drive/cell_images.zip'
extracted_path = '/content/cell_images'

with zipfile.ZipFile(dataset_path, 'r') as zip_ref:
    zip_ref.extractall(extracted_path)
print("Dataset extracted.")

# paths for training and testing data
train_dir = os.path.join(extracted_path, 'train')
test_dir = os.path.join(extracted_path, 'test')
print(f"Training path: {train_dir}\nTesting path: {test_dir}")

"""Preporcessing and augmentation"""

# parameters for image processing
IMG_WIDTH, IMG_HEIGHT = 128, 128
BATCH_SIZE = 32

# Data augmentation for training
train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True
)

# Rescaling
test_datagen = ImageDataGenerator(rescale=1./255)

# Creating generators
train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=(IMG_WIDTH, IMG_HEIGHT),
    batch_size=BATCH_SIZE,
    class_mode='binary'
)

test_generator = test_datagen.flow_from_directory(
    test_dir,
    target_size=(IMG_WIDTH, IMG_HEIGHT),
    batch_size=BATCH_SIZE,
    class_mode='binary'
)

"""Build the DL model (CNN)"""

# Building the CNN model
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(IMG_WIDTH, IMG_HEIGHT, 3)),
    MaxPooling2D((2, 2)),
    Dropout(0.2),

    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Dropout(0.3),

    Conv2D(128, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Dropout(0.4),

    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.5),
    Dense(1, activation='sigmoid')
])

# Compiling the model
model.compile(optimizer=Adam(learning_rate=0.001),
              loss='binary_crossentropy',
              metrics=['accuracy'])

model.summary() #summarize the model

"""Train the model"""

# Early stopping to prevent overfitting
early_stopping = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

# Training the  model
history = model.fit(
    train_generator,
    validation_data=test_generator,
    epochs=50,
    callbacks=[early_stopping]
)

"""Evaluation of model"""

# Evaluate of model based on the test data
test_loss, test_accuracy = model.evaluate(test_generator)
print(f"Test Loss: {test_loss:.4f}, Test Accuracy: {test_accuracy:.4f}")

# Classification report and confusion matrix
y_true = test_generator.classes
y_pred = (model.predict(test_generator) > 0.5).astype('int32')

print("Classification Report:\n", classification_report(y_true, y_pred))
print("Confusion Matrix:\n", confusion_matrix(y_true, y_pred))

"""Visualize training results"""

# Plot training history
plt.figure(figsize=(12, 5))

# plot Accuracy
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()

# plot Loss
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

plt.tight_layout()
plt.show()

"""Saving the model"""

# Saving the model
model.save('/content/malaria_detection_model.h5')
print("Model saved successfully.")

"""LOad the saved model"""

# Load the saved model
from tensorflow.keras.models import load_model

saved_model = load_model('/content/malaria_detection_model.h5')
print("Model loaded.")

"""Function to identify whether it is infected or not"""

from tensorflow.keras.preprocessing.image import load_img, img_to_array

# Function to preprocess the input image and predict malaria infection
def predict_malaria(image_path, model):
    # Load the image with target size
    img = load_img(image_path, target_size=(IMG_WIDTH, IMG_HEIGHT))
    plt.imshow(img)  # Display the image for your reference
    plt.axis('off')
    plt.show()

    # Preprocess the image
    img_array = img_to_array(img)  # Convert to numpy array
    img_array = img_array / 255.0  # Normalizing
    img_array = np.expand_dims(img_array, axis=0)

    # Predict the result
    prediction = model.predict(img_array)
    if prediction[0][0] > 0.5:
        print("The cell is **Uninfected** (Not Affected by Malaria).")
    else:
        print("The cell is **Parasitized** (Affected by Malaria).")

"""Uploading a test image"""

from google.colab import files #import necessary library

while True:
    uploaded = files.upload() # to upload the image
    image_path = next(iter(uploaded.keys()))
    predict_malaria(image_path, model)
    user_input = input("Do you want to continue? (yes/no): ").strip().lower()
    if user_input == 'no':
        print("Exiting the program.")
        break
    elif user_input != 'yes':
        print("Invalid input. Please answer with 'yes' or 'no'.")